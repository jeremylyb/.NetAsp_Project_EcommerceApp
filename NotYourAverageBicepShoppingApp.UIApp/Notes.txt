1. Dependency Inject in UIApp MVC Project to allow specific HTTPClient to be injected everytime it is called in controller
	- builder.Services.AddHttpClient("ProductsApiClient", ...): 
			This line configures the dependency injection container (Services) to register an HttpClient named "ProductsApiClient". 
			The AddHttpClient method sets up an HttpClient with the specified name and allows you to configure its settings using a lambda expression.
			Inside the lambda expression:
				httpClient.DefaultRequestHeaders.Accept.Add(...): 
					This configures the default request headers of the HttpClient. In this case, it sets the Accept header to specify that the client accepts responses in JSON format.

				httpClient.BaseAddress = new Uri("https://localHost:7096"): 
					This sets the base address (root URL) for the HttpClient. All requests made using this HttpClient will be relative to this base address.
					Have to ensure that this correspond to the specific REST API port number
		
		- builder.Services.AddScoped<IProductsClient, ProductsClient>(): 
			This line registers the ProductsClient class as a service with the dependency injection container. 
			It specifies that whenever an IProductsClient is requested, an instance of ProductsClient should be provided. 
			The Scoped lifetime means that a new instance of ProductsClient will be created for each scope (typically, each HTTP request in the context of a web application).
			This concept is similar to AddDbContext for REST API where we dependency inject and tells the application to provide instances whenever requested

2. Why we need to create an Interface-Concrete Class construct for Client:
	Benefits:
			- Abstraction: 
				By defining an interface for your APIClient, you create an abstraction layer that separates the implementation 
				details from the rest of your application. This allows you to easily switch between different implementations 
				of the APIClient (e.g., for testing purposes or if you need to interact with different APIs).

			- Dependency Injection: 
				Defining an interface allows you to inject instances of the APIClient into other classes or components using 
				dependency injection. This promotes loose coupling and makes your code more modular and testable.

			- Testability: 
				Interfaces make it easier to mock or stub the APIClient in unit tests. You can create mock implementations of 
				the interface that simulate the behavior of the real APIClient, allowing you to isolate the code you're testing 
				from external dependencies.

			- Code Contracts: 
				Interfaces serve as contracts that define the methods and properties that any implementation of the APIClient 
				must adhere to. This helps enforce consistency and maintainability in your codebase, especially when working in a 
				team environment

3. Why do we need to duplicate Model class in REST API to MVC Project?

	Including the model class in both your UI (MVC) project and your REST API project serves different purposes and is a common 
	practice in software development for several reasons:

	Separation of Concerns: 
		The MVC pattern separates concerns such as Model, View, and Controller. The model classes in your MVC project are typically 
		ViewModel classes that are tailored specifically for rendering views. On the other hand, the model classes in your REST API 
		project are often domain model classes representing your business logic and data structures. By keeping them separate, you 
		maintain a clear separation of concerns and prevent tight coupling between your UI and your business logic.

	Versioning and Evolution: 
		Your API model classes might evolve differently from your UI model classes. They may have additional fields, different 
		validation requirements, or other changes that are specific to the API contract. By having separate model classes, 
		you can evolve each part of your application independently without affecting the other.

	Reducing Dependencies: 
		If you were to directly import the models from your API project into your UI project, you would introduce a tight coupling 
		between your UI and your API. This can lead to issues when you need to make changes or updates, as any changes to the API 
		models could potentially impact your UI directly. By keeping them separate, you reduce dependencies and make your codebase 
		more modular and maintainable.

	Security: 
		Exposing your domain model directly to the UI may expose sensitive information or business logic that should not be exposed 
		to the client. By having separate ViewModel classes in your UI project, you can control exactly what data is exposed to the client.

However, you can use tools like AutoMapper to help automate the process of mapping between your domain model classes and your ViewModel 
classes, reducing the amount of boilerplate code required.

In summary, while it might seem redundant to have similar model classes in both your UI and API projects, it's a common and recommended 
practice to maintain separation of concerns, versioning, and flexibility in your application architecture.

4. What is HttpClientFactory

	HttpClientFactory is a feature introduced in ASP.NET Core 2.1 to address several issues and improve the management of HttpClient instances 
	in .NET applications. Traditionally, developers have created instances of HttpClient directly in their code whenever they needed to make 
	HTTP requests. However, creating HttpClient instances directly can lead to various problems, including socket exhaustion, DNS resolution 
	issues, and inefficient resource management.

	HttpClientFactory provides a more efficient and centralized way to manage and create instances of HttpClient. It abstracts away the 
	complexities of managing HttpClient instances and provides benefits such as:

	Resource Management: 
		HttpClientFactory manages the lifecycle of HttpClient instances, ensuring efficient usage of resources and avoiding socket exhaustion issues.

	Reuse of Connections: 
		HttpClientFactory enables connection pooling, allowing HttpClient instances to reuse connections to the same destination server, 
		improving performance and reducing latency.

	Configuration Flexibility: 
		HttpClient instances can be configured centrally in the application's startup code or using the options pattern, making it easier 
		to manage settings like base addresses, default headers, timeouts, and more.

	Scalability: 
		HttpClientFactory supports creating and managing multiple named HttpClient instances with different configurations, allowing applications 
		to make requests to different APIs or services with different settings.

	Logging and Diagnostics: 
		HttpClientFactory integrates with the ASP.NET Core logging system, enabling logging of HTTP requests and responses for debugging and monitoring purposes.

	By leveraging HttpClientFactory, developers can build more efficient, scalable, and maintainable HTTP client code in their ASP.NET Core 
	applications while avoiding common pitfalls associated with managing HttpClient instances manually.


5. In MVC project, should we implement try catch in UI Controller or in Client class?

	Client-side Error Handling:
		Implementing error handling in the client code (e.g., in your HttpClient or service layer) allows you to handle errors that occur 
		during the HTTP request/response cycle.
		Client-side error handling can include catching exceptions thrown by the HTTP client library (e.g., HttpRequestException) and handling specific 
		error conditions returned by the server (e.g., HTTP status codes indicating errors).
		You can provide feedback to the user or perform appropriate actions based on the type of error encountered, such as displaying error messages, 
		retrying the request, or navigating to a different page.

	Controller-level Error Handling:
		Implementing error handling in the controller allows you to handle errors that occur during the processing of incoming requests or the execution of controller actions.
		Controller-level error handling can include catching exceptions thrown by action methods or other components within the controller, as well as 
		handling errors returned by service layer methods.
		You can customize error responses returned to the client, log error details for troubleshooting purposes, and perform cleanup or recovery actions as needed.

6. Type of return in MVC Controller
	
	In an MVC (Model-View-Controller) application, a controller action method can return various types of results, depending on the requirements of the application and 
	the desired behavior for handling the request. Some common return types for controller action methods in ASP.NET Core MVC include:

	ViewResult:
		Represents an HTML view that will be rendered and returned to the client.
		Typically used when you want to render an HTML page to display data to the user.

		public IActionResult Index()
		{
			return View();
		}

	PartialViewResult:
		Represents a partial view that can be rendered within another view or as a standalone component.
		Useful for rendering reusable components or sections of a page.

		public IActionResult Sidebar()
		{
			return PartialView("_Sidebar");
		}

	RedirectResult:
		Represents a redirection to a different URL.
		Used when you want to redirect the user to another page or action method.

		public IActionResult RedirectExample()
		{
			return Redirect("/Home/Index");
		}

	JsonResult:
		Represents a JSON response that will be returned to the client.
		Typically used for AJAX requests or when you need to return structured data.

		public IActionResult GetJsonData()
		{
			var data = new { Name = "John", Age = 30 };
			return Json(data);
		}
	
	ContentResult:
		Represents a custom content that will be returned to the client, such as plain text or XML.
		Useful for returning non-HTML content or custom responses.

		public IActionResult PlainText()
		{
			return Content("Hello, world!", "text/plain");
		}
	
	FileResult:
		Represents a file that will be returned to the client for download.
		Used when you need to provide a file download to the user.

		public IActionResult DownloadFile()
		{
			byte[] fileContents = // Get file contents
			string contentType = // Get content type
			string fileName = // Get file name
			return File(fileContents, contentType, fileName);
		}

	These are some common return types in ASP.NET Core MVC controllers, but there are also other types like StatusCodeResult, EmptyResult, 
	and custom result types that can be used based on the specific requirements of your application.

7. How Object passed into ViewResult - View() process work

	- Passing the Object from Controller to ViewResult:
		In your controller action method, you create an instance of the object you want to pass to the view and then return a ViewResult, 
		passing the object as an argument to the View method:

		public IActionResult Index()
		{
			var model = new MyModel { /* Initialize model properties */ }; 
			return View(model);
		}

	- Receiving the Model in the View:
		In the corresponding view (typically a .cshtml file), you declare the model type at the top of the file using the @model directive.
		This tells the view engine to expect a model of that type.

		@model MyNamespace.MyModel

	- Accessing Model Properties in the View:
		Once the model is declared, you can access its properties and methods directly within the view using Razor syntax (@Model.PropertyName):

		<div>
			<p>Name: @Model.Name</p>
			<p>Age: @Model.Age</p>
		</div>

		Here, Model.Name and Model.Age represent properties of the MyModel object passed from the controller.

	- Rendering HTML Dynamically with Model Data:
		Using the model data, you can dynamically generate HTML content within the view, incorporating the values of the model properties as needed.

		<h1>Welcome, @Model.Name!</h1>
		<p>Your age is @Model.Age years old.</p>
		
		The HTML content generated in the view will reflect the data provided by the model.

	In summary, passing an object from a controller to a ViewResult allows you to provide dynamic data to the view, which can then be accessed and used to 
	generate HTML content dynamically. This separation of concerns between the controller (handling business logic and data) and the view (displaying the data) 
	is a fundamental principle of the MVC pattern.

8.	View -> MVC Project Controller -> Logic + DBContext Approach 
	VS 
	View -> MVC Project Controller -> Client Class -> REST API Project Controller -> DbContext

	Your Approach (Using MVC Project Controller to Call a Client Class):
		In your approach, the MVC project controller is responsible for interacting with a client class, which in turn communicates with the 
		REST API project. This creates a separation of concerns where the MVC project focuses on user interactions and presentation logic, while the client class 
		handles the communication with the backend API.
	
	Alternative Approach (Direct Interaction within MVC Project Controller):
		In the alternative approach I described earlier, the MVC project controller directly interacts with the database using a DbContext 
		and handles the entire process within the controller action. This approach combines both data access and presentation logic within the controller.
	
	Both approaches have their pros and cons:
	Your Approach:
		Pros:
		Separation of concerns: MVC project focuses solely on presentation logic while the client class handles API communication.
		Easier to maintain and test: Client class can be tested independently, and changes to API endpoints can be easily managed within the client class.
		Cons:
		Additional complexity: Introducing a client class adds another layer of abstraction, which may increase complexity.
		Overhead: Extra overhead of managing client class and API communication.

	Alternative Approach:
		Pros:
		Simplified architecture: Direct interaction within the controller may simplify the application structure for smaller projects.
		Less overhead: Eliminates the need for a separate client class, reducing overhead.
		Cons:
		Violates separation of concerns: Combining data access and presentation logic within the controller may violate the separation of concerns principle.
		Harder to maintain and test: Controller actions become larger and harder to test as they handle both presentation and data access logic.
		In terms of compliance with design patterns, both approaches can be valid depending on the specific requirements and preferences of your project. 
		If your project prioritizes separation of concerns and scalability, your approach of using a client class to interact with the API aligns well with 
		the principles of the layered architecture pattern. However, if your project is small or has simpler requirements, the alternative approach may be more practical.

	Ultimately, it's essential to consider factors such as project size, complexity, maintainability, and scalability when choosing the appropriate design pattern for your application.

9. What is the difference between ReadAsStreamAsync() and ReadAsStringAsync()

	The difference between ReadAsStreamAsync() and ReadAsStringAsync() lies in how they read the response content from an HttpContent object:

	ReadAsStreamAsync():
	This method reads the response content as a Stream. It returns a Task<Stream> representing the asynchronous operation of reading the content.
	When you use ReadAsStreamAsync(), you'll get a stream that represents the raw binary data of the response body. This is useful when dealing with large or binary data where you 
	want to stream the content rather than loading it all into memory at once.
	You typically use this method when dealing with non-textual data, such as images, videos, or other binary formats, or when you want to process large textual data without loading 
	it entirely into memory.

	ReadAsStringAsync():
	This method reads the response content as a string. It returns a Task<string> representing the asynchronous operation of reading the content.
	When you use ReadAsStringAsync(), you'll get the response content as a string. This is useful when dealing with textual data, such as JSON or HTML responses, where you want 
	to process the content as a string.
	You typically use this method when dealing with textual data that you need to parse or manipulate as a string, such as JSON responses that you want to deserialize into objects or 
	HTML content that you want to display or extract information from.
	In summary, ReadAsStreamAsync() returns a stream representing the raw binary data of the response body, while ReadAsStringAsync() returns the response content as a string. You would 
	choose one over the other based on the nature of the content you expect to receive and how you intend to process it.

10. GetStreamAsync() vs GetStringAsync() 
	
	In Post/Put method, typically we would want to return the object back for display or any other presentation logic. Hence, GetStreamAsync can be more efficient since GetAsync
	we would need to ReadAsStreamAsync back in order to deserialize it.

	Both method Works

	        public async Task<Product?> GetProductByIdAsync(string id)
        {
            try
            {
                var client = _httpClientFactory.CreateClient("ProductsApiClient");

					"GetStreamAsync"
                var productByIdStreamTask = await client.GetStreamAsync($"/api/Products/{id}");
                return await JsonSerializer.DeserializeAsync<Product>(productByIdStreamTask);

					"GetAsync"
                HttpResponseMessage response = await client.GetAsync($"/api/Products/{id}");
                return await JsonSerializer.DeserializeAsync<Product>(await response.Content.ReadAsStreamAsync());
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error: {ex.Message}");
                throw;
            }
        }